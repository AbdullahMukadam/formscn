{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "use-field-dependencies",
  "description": "Hook to manage field dependencies and conditional logic",
  "dependencies": [
    "react-hook-form"
  ],
  "registryDependencies": [
    "http://localhost:3001/r/form-utils.json"
  ],
  "files": [
    {
      "path": "src/registry/default/hooks/use-field-dependencies.ts",
      "content": "\"use client\";\n\nimport { useEffect, useMemo } from \"react\";\nimport type { UseFormReturn, FieldValues, FieldPath } from \"react-hook-form\";\nimport { getFieldValue } from \"../lib/form-utils\";\n\nexport type ConditionOperator =\n  | \"equals\"\n  | \"notEquals\"\n  | \"contains\"\n  | \"notContains\"\n  | \"greaterThan\"\n  | \"lessThan\"\n  | \"greaterThanOrEqual\"\n  | \"lessThanOrEqual\"\n  | \"isEmpty\"\n  | \"isNotEmpty\"\n  | \"includes\"\n  | \"notIncludes\";\n\nexport interface FieldCondition {\n  /**\n   * Field to watch\n   */\n  field: string;\n\n  /**\n   * Condition operator\n   */\n  operator: ConditionOperator;\n\n  /**\n   * Value to compare against (not needed for isEmpty/isNotEmpty)\n   */\n  value?: any;\n}\n\nexport interface CompositeCondition {\n  /**\n   * Logical operator for combining conditions\n   */\n  operator: \"and\" | \"or\";\n\n  /**\n   * Array of conditions to evaluate\n   */\n  conditions: (FieldCondition | CompositeCondition)[];\n}\n\nexport type Condition = FieldCondition | CompositeCondition;\n\n/**\n * Evaluate a single field condition\n */\nfunction evaluateFieldCondition(\n  condition: FieldCondition,\n  formValues: Record<string, any>\n): boolean {\n  const fieldValue = getFieldValue(formValues, condition.field);\n  const { operator, value } = condition;\n\n  switch (operator) {\n    case \"equals\":\n      return fieldValue === value;\n\n    case \"notEquals\":\n      return fieldValue !== value;\n\n    case \"contains\":\n      return (\n        typeof fieldValue === \"string\" &&\n        typeof value === \"string\" &&\n        fieldValue.includes(value)\n      );\n\n    case \"notContains\":\n      return (\n        typeof fieldValue === \"string\" &&\n        typeof value === \"string\" &&\n        !fieldValue.includes(value)\n      );\n\n    case \"greaterThan\":\n      return typeof fieldValue === \"number\" && fieldValue > value;\n\n    case \"lessThan\":\n      return typeof fieldValue === \"number\" && fieldValue < value;\n\n    case \"greaterThanOrEqual\":\n      return typeof fieldValue === \"number\" && fieldValue >= value;\n\n    case \"lessThanOrEqual\":\n      return typeof fieldValue === \"number\" && fieldValue <= value;\n\n    case \"isEmpty\":\n      return (\n        fieldValue === null ||\n        fieldValue === undefined ||\n        fieldValue === \"\" ||\n        (Array.isArray(fieldValue) && fieldValue.length === 0)\n      );\n\n    case \"isNotEmpty\":\n      return !(\n        fieldValue === null ||\n        fieldValue === undefined ||\n        fieldValue === \"\" ||\n        (Array.isArray(fieldValue) && fieldValue.length === 0)\n      );\n\n    case \"includes\":\n      return Array.isArray(fieldValue) && fieldValue.includes(value);\n\n    case \"notIncludes\":\n      return Array.isArray(fieldValue) && !fieldValue.includes(value);\n\n    default:\n      return false;\n  }\n}\n\n/**\n * Recursively evaluate a condition (simple or composite)\n */\nfunction evaluateCondition(\n  condition: Condition,\n  formValues: Record<string, any>\n): boolean {\n  // Check if it's a composite condition\n  if (\"conditions\" in condition) {\n    const results = condition.conditions.map((cond) =>\n      evaluateCondition(cond, formValues)\n    );\n\n    if (condition.operator === \"and\") {\n      return results.every((result) => result);\n    } else {\n      // \"or\"\n      return results.some((result) => result);\n    }\n  }\n\n  // It's a field condition\n  return evaluateFieldCondition(condition as FieldCondition, formValues);\n}\n\n/**\n * Extract all field names from a condition tree\n */\nfunction extractWatchFields(condition: Condition): string[] {\n  if (\"conditions\" in condition) {\n    return condition.conditions.flatMap((cond) => extractWatchFields(cond));\n  }\n\n  return [(condition as FieldCondition).field];\n}\n\n/**\n * Hook to manage field dependencies and conditional logic\n * \n * @example\n * ```tsx\n * const form = useForm();\n * const showCompanyFields = useFieldDependencies(form, {\n *   field: \"accountType\",\n *   operator: \"equals\",\n *   value: \"business\"\n * });\n * \n * return (\n *   <>\n *     <FormSelect name=\"accountType\" />\n *     {showCompanyFields && (\n *       <>\n *         <FormInput name=\"companyName\" />\n *         <FormInput name=\"taxId\" />\n *       </>\n *     )}\n *   </>\n * );\n * ```\n */\nexport function useFieldDependencies<TFieldValues extends FieldValues>(\n  form: UseFormReturn<TFieldValues>,\n  condition: Condition,\n  options?: {\n    /**\n     * Clear dependent field values when condition becomes false\n     * @default false\n     */\n    clearOnHide?: boolean;\n\n    /**\n     * Fields to clear when condition becomes false\n     */\n    fieldsToReset?: FieldPath<TFieldValues>[];\n  }\n): boolean {\n  const { clearOnHide = false, fieldsToReset = [] } = options || {};\n\n  // Watch all fields mentioned in the condition\n  const fieldsToWatch = useMemo(\n    () => extractWatchFields(condition),\n    [condition]\n  );\n\n  const values = form.watch(fieldsToWatch as any);\n\n  // Evaluate the condition\n  const isSatisfied = useMemo(() => {\n    const formValues = form.getValues();\n    return evaluateCondition(condition, formValues);\n  }, [values, condition, form]);\n\n  // Clear fields when condition becomes false\n  useEffect(() => {\n    if (!isSatisfied && clearOnHide && fieldsToReset.length > 0) {\n      fieldsToReset.forEach((field) => {\n        form.setValue(field, undefined as any, { shouldDirty: false });\n      });\n    }\n  }, [isSatisfied, clearOnHide, fieldsToReset, form]);\n\n  return isSatisfied;\n}\n",
      "type": "registry:hook"
    }
  ],
  "type": "registry:hook"
}