{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "form-generator",
  "description": "Form code generation utilities",
  "dependencies": [
    "zod"
  ],
  "files": [
    {
      "path": "src/registry/default/lib/form-generator.ts",
      "content": "import * as z from \"zod\";\nimport { OAUTH_PROVIDERS, type OAuthProvider } from \"@/lib/oauth-providers-config\";\nimport { type FormTemplate, type FormField } from \"@/registry/default/types\";\n\nexport type { OAuthProvider } from \"@/lib/oauth-providers-config\";\nexport type DatabaseAdapter = \"drizzle\" | \"prisma\";\nexport type Framework = \"next\" | \"react\" | \"tanstack\" | \"remix\";\n\n/**\n * Generate imports for the form component\n */\nfunction generateImports(config: {\n  framework: Framework;\n  fields: FormField[];\n  oauthProviders: OAuthProvider[];\n  isAuth: boolean;\n  isLogin: boolean;\n  isSignup: boolean;\n  hasOAuth: boolean;\n  oauthIcons: string;\n}): string {\n  const { framework, fields, isAuth, isLogin, isSignup, hasOAuth, oauthIcons } = config;\n  \n  const directive = (framework === \"next\" || framework === \"tanstack\") ? '\"use client\";\\n\\n' : \"\";\n\n  const hasSelect = fields.some(f => f.type === \"select\");\n  const hasCheckbox = fields.some(f => f.type === \"checkbox\");\n  const hasTextarea = fields.some(f => f.type === \"textarea\");\n  const hasRadio = fields.some(f => f.type === \"radio\");\n\n  let imports = `${directive}import { useForm${(hasSelect || hasCheckbox || hasRadio) ? \", Controller\" : \"\"} } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport * as z from \"zod\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { toast } from \"sonner\";`;\n\n  if (hasTextarea) {\n    imports += `\\nimport { Textarea } from \"@/components/ui/textarea\";`;\n  }\n  \n  if (hasSelect) {\n    imports += `\\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";`;\n  }\n\n  if (hasCheckbox) {\n    imports += `\\nimport { Checkbox } from \"@/components/ui/checkbox\";`;\n  }\n\n  if (hasRadio) {\n    imports += `\\nimport { RadioGroup, RadioGroupItem } from \"@/components/ui/radio-group\";`;\n  }\n\n  // Auth Imports\n  if (isAuth) {\n    const authImports = [];\n    if (isLogin || hasOAuth) authImports.push(\"signIn\");\n    if (isSignup) authImports.push(\"signUp\");\n    \n    imports += `\\nimport { ${authImports.join(\", \")} } from \"@/lib/auth-client\";`;\n    \n    if (hasOAuth && oauthIcons) {\n      imports += `\\nimport { ${oauthIcons} } from \"lucide-react\";`;\n    }\n  }\n\n  return imports;\n}\n\n/**\n * Generate Zod schema definition\n */\nfunction generateZodSchema(fields: FormField[]): string {\n  const schemaFields = fields.map((field) => {\n    if (field.type === \"input\") {\n      let validation = `z.string()`;\n      if (field.inputType === \"email\") validation += `.email(\"Invalid email address\")`;\n      if (field.required) validation += `.min(1, \"${field.label} is required\")`;\n      else validation += `.optional().or(z.literal(\"\"))`;\n      return `  ${field.name}: ${validation},`;\n    }\n    if (field.type === \"textarea\") {\n      let validation = `z.string()`;\n      if (field.required) validation += `.min(1, \"${field.label} is required\")`;\n      else validation += `.optional().or(z.literal(\"\"))`;\n      return `  ${field.name}: ${validation},`;\n    }\n    if (field.type === \"checkbox\") {\n      let validation = `z.boolean()`;\n      if (field.required) validation += `.refine((val) => val === true, { message: \"You must agree to ${field.label}\" })`;\n      else validation += `.default(false)`;\n      return `  ${field.name}: ${validation},`;\n    }\n    if (field.type === \"select\" || field.type === \"radio\") {\n      const enumValues = (field.options || []).map(opt => `\"${opt.value}\"`).join(', ');\n      let validation = `z.enum([${enumValues}])`;\n      if (!field.required) validation += `.optional()`;\n      return `  ${field.name}: ${validation},`;\n    }\n    return `  ${field.name}: z.any(),`;\n  }).join('\\n');\n\n  return `\nconst formSchema = z.object({\n${schemaFields}\n});\n\ntype FormValues = z.infer<typeof formSchema>;`;\n}\n\n/**\n * Generate JSX for form fields\n */\nfunction generateFormFields(fields: FormField[]): string {\n  return fields.map((field) => {\n    const errorDisplay = `{form.formState.errors.${field.name} && (\n            <p className=\"text-sm text-destructive\">{form.formState.errors.${field.name}.message}</p>\n          )}`;\n    const descriptionDisplay = field.description ? `\\n          <p className=\"text-sm text-muted-foreground\">${field.description}</p>` : \"\";\n\n    if (field.type === \"input\") {\n      return `          <div className=\"space-y-2\">\n            <Label htmlFor=\"${field.name}\">${field.label}</Label>\n            <Input\n              id=\"${field.name}\"\n              type=\"${field.inputType || \"text\"}\"\n              placeholder=\"${field.placeholder || \"\"}\"\n              {...form.register(\"${field.name}\")}\n            />\n            ${errorDisplay}${descriptionDisplay}\n          </div>`;\n    }\n    if (field.type === \"textarea\") {\n      return `          <div className=\"space-y-2\">\n            <Label htmlFor=\"${field.name}\">${field.label}</Label>\n            <Textarea\n              id=\"${field.name}\"\n              placeholder=\"${field.placeholder || \"\"}\"\n              {...form.register(\"${field.name}\")}\n            />\n            ${errorDisplay}${descriptionDisplay}\n          </div>`;\n    }\n    if (field.type === \"select\") {\n      return `          <div className=\"space-y-2\">\n            <Label htmlFor=\"${field.name}\">${field.label}</Label>\n            <Controller\n              control={form.control}\n              name=\"${field.name}\"\n              render={({ field }) => (\n                <Select onValueChange={field.onChange} defaultValue={field.value}>\n                  <SelectTrigger id=\"${field.name}\">\n                    <SelectValue placeholder=\"${field.placeholder || \"Select an option\"}\" />\n                  </SelectTrigger>\n                  <SelectContent>\n                    ${(field.options || []).map(opt => `<SelectItem value=\"${opt.value}\">${opt.label}</SelectItem>`).join('\\n                    ')}\n                  </SelectContent>\n                </Select>\n              )}\n            />\n            ${errorDisplay}${descriptionDisplay}\n          </div>`;\n    }\n    if (field.type === \"radio\") {\n      return `          <div className=\"space-y-2\">\n            <Label>${field.label}</Label>\n            <Controller\n              control={form.control}\n              name=\"${field.name}\"\n              render={({ field }) => (\n                <RadioGroup\n                  onValueChange={field.onChange}\n                  defaultValue={field.value}\n                  className=\"flex flex-col space-y-1\"\n                >\n                  ${(field.options || []).map(opt => `<div className=\"flex items-center space-x-2\">\n                    <RadioGroupItem value=\"${opt.value}\" id=\"${field.name}-${opt.value}\" />\n                    <Label htmlFor=\"${field.name}-${opt.value}\">${opt.label}</Label>\n                  </div>`).join('\\n                  ')}\n                </RadioGroup>\n              )}\n            />\n            ${errorDisplay}${descriptionDisplay}\n          </div>`;\n    }\n    if (field.type === \"checkbox\") {\n      return `          <div className=\"flex items-center space-x-2\">\n            <Controller\n              control={form.control}\n              name=\"${field.name}\"\n              render={({ field }) => (\n                <Checkbox\n                  id=\"${field.name}\"\n                  checked={field.value}\n                  onCheckedChange={field.onChange}\n                />\n              )}\n            />\n            <Label htmlFor=\"${field.name}\" className=\"font-normal\">\n              ${field.label}\n            </Label>\n            ${errorDisplay}\n          </div>`;\n    }\n    return `          {/* ${field.type} field for ${field.name} */}`;\n  }).join('\\n\\n');\n}\n\n/**\n * Generate submit logic code\n */\nfunction generateSubmitLogic(config: {\n  isLogin: boolean;\n  isSignup: boolean;\n  fields: FormField[];\n}): string {\n  const { isLogin, isSignup, fields } = config;\n\n  if (isLogin) {\n    return `    await signIn.email({\n      email: data.email,\n      password: data.password,\n      callbackURL: \"/dashboard\",\n      fetchOptions: {\n        onResponse: () => {\n          // toast.loading(\"Logging in...\");\n        },\n        onRequest: () => {\n          toast.loading(\"Logging in...\");\n        },\n        onSuccess: () => {\n          toast.dismiss();\n          toast.success(\"Logged in successfully!\");\n        },\n        onError: (ctx) => {\n          toast.dismiss();\n          toast.error(ctx.error.message);\n        },\n      },\n    });`;\n  } \n  \n  if (isSignup) {\n    // Find name field (fullName, name, etc)\n    const nameField = fields.find(f => f.name.toLowerCase().includes('name'))?.name || 'name';\n    \n    return `    await signUp.email({\n      email: data.email,\n      password: data.password,\n      name: data.${nameField},\n      callbackURL: \"/dashboard\",\n      fetchOptions: {\n        onResponse: () => {\n          // toast.loading(\"Creating account...\");\n        },\n        onRequest: () => {\n          toast.loading(\"Creating account...\");\n        },\n        onSuccess: () => {\n          toast.dismiss();\n          toast.success(\"Account created successfully!\");\n        },\n        onError: (ctx) => {\n          toast.dismiss();\n          toast.error(ctx.error.message);\n        },\n      },\n    });`;\n  }\n\n  return `    console.log(\"Form submitted:\", data);\n    toast.success(\"Form submitted successfully!\");`;\n}\n\n/**\n * Generate OAuth buttons JSX\n */\nfunction generateOAuthButtons(oauthProviders: OAuthProvider[]): string {\n  return oauthProviders.map(providerId => {\n    const provider = OAUTH_PROVIDERS.find(p => p.id === providerId);\n    if (!provider) return '';\n\n    const iconComponent = provider.iconSvg || `<${provider.icon.name} className=\"mr-2 h-4 w-4\" />`;\n\n    return `          <Button\n            variant=\"outline\"\n            onClick={() => signIn.social({ provider: \"${provider.betterAuthId}\" })}\n          >\n            ${iconComponent}\n            ${provider.name}\n          </Button>`;\n  }).filter(Boolean).join('\\n');\n}\n\n/**\n * Generate a complete form component with Better Auth integration\n */\nexport function generateFormComponent(config: {\n  formName: string;\n  formDescription: string;\n  fields: FormField[];\n  oauthProviders: OAuthProvider[];\n  framework?: Framework;\n}): string {\n  const { formName, formDescription, fields, oauthProviders, framework = \"next\" } = config;\n  \n  const hasOAuth = oauthProviders.length > 0;\n  \n  // Extract OAuth icons to import\n  const oauthIcons = oauthProviders\n    .map(id => OAUTH_PROVIDERS.find(p => p.id === id))\n    .filter((p): p is NonNullable<typeof p> => p !== undefined)\n    .filter(p => !p.iconSvg) // Only import icons that aren't custom SVG\n    .map(p => p.icon.name)\n    .filter((name, index, self) => self.indexOf(name) === index) // Remove duplicates\n    .join(', ');\n\n  // Auth Detection\n  const hasEmail = fields.some(f => f.name === \"email\" || f.inputType === \"email\");\n  const hasPassword = fields.some(f => f.name === \"password\" || f.inputType === \"password\");\n  const hasConfirmPassword = fields.some(f => f.name === \"confirmPassword\");\n  \n  const isLogin = hasEmail && hasPassword && !hasConfirmPassword;\n  const isSignup = hasEmail && hasPassword && hasConfirmPassword;\n  const isAuth = isLogin || isSignup || hasOAuth;\n\n  // Generate parts\n  const imports = generateImports({\n    framework,\n    fields,\n    oauthProviders,\n    isAuth,\n    isLogin,\n    isSignup,\n    hasOAuth,\n    oauthIcons\n  });\n\n  const schema = generateZodSchema(fields);\n  const formFields = generateFormFields(fields);\n  const oauthButtons = generateOAuthButtons(oauthProviders);\n  const submitLogic = generateSubmitLogic({ isLogin, isSignup, fields });\n\n  // Generate component\n  const componentName = formName.replace(/\\s+/g, '') + 'Form';\n  const defaultValues = fields.map(f => `      ${f.name}: ${f.type === \"checkbox\" ? \"false\" : '\"\"'},`).join('\\n');\n\n  const component = `\nexport function ${componentName}() {\n  const form = useForm<FormValues>({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n${defaultValues}\n    },\n  });\n\n  const onSubmit = async (data: FormValues) => {\n${submitLogic}\n  };\n\n  return (\n    <Card className=\"w-full max-w-md mx-auto\">\n      <CardHeader>\n        <CardTitle>${formName}</CardTitle>\n        <CardDescription>${formDescription}</CardDescription>\n      </CardHeader>\n      <CardContent>\n        <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n${formFields}\n\n          <Button type=\"submit\" className=\"w-full\">Submit</Button>\n        </form>${hasOAuth ? `\n        <div className=\"relative my-4\">\n          <div className=\"absolute inset-0 flex items-center\">\n            <span className=\"w-full border-t\" />\n          </div>\n          <div className=\"relative flex justify-center text-xs uppercase\">\n            <span className=\"bg-background px-2 text-muted-foreground\">\n              Or continue with\n            </span>\n          </div>\n        </div>\n\n        <div className=\"grid grid-cols-${oauthProviders.length} gap-4\">\n${oauthButtons}\n        </div>` : ''}\n      </CardContent>\n    </Card>\n  );\n}`;\n\n  return `${imports}${schema}${component}`;\n}\n\n/**\n * Generate Better Auth configuration\n */\nexport function generateAuthConfig(config: {\n  oauthProviders: OAuthProvider[];\n  hasEmailPassword: boolean;\n  databaseAdapter?: DatabaseAdapter;\n  framework?: Framework;\n}): string {\n  const { oauthProviders, hasEmailPassword, databaseAdapter = \"drizzle\", framework = \"next\" } = config;\n  \n  let envPrefix = \"process.env.\";\n  let envSuffix = \"!\";\n\n  if (framework === \"react\" || framework === \"tanstack\") {\n    envPrefix = \"import.meta.env.VITE_\";\n    envSuffix = \"\";\n  } else if (framework === \"remix\") {\n    envPrefix = \"process.env.\"; // Remix server-side usually standard process.env\n    envSuffix = \"!\"; // Remix client-side depends on how they expose envs, but for auth config (server), it's standard\n  }\n\n  const socialProviders = oauthProviders.map(provider => {\n    return `    ${provider}: {\n      clientId: ${envPrefix}${provider.toUpperCase()}_CLIENT_ID${envSuffix},\n      clientSecret: ${envPrefix}${provider.toUpperCase()}_CLIENT_SECRET${envSuffix},\n    },`;\n  }).join('\\n');\n\n  if (databaseAdapter === \"prisma\") {\n    return `import { betterAuth } from \"better-auth\";\nimport { prismaAdapter } from \"better-auth/adapters/prisma\";\nimport { prisma } from \"@/lib/prisma\"; // Import your Prisma client\n\nexport const auth = betterAuth({\n  database: prismaAdapter(prisma, {\n    provider: \"postgresql\", // Options: \"postgresql\", \"mysql\", \"sqlite\"\n  }),${hasEmailPassword ? `\n  emailAndPassword: {\n    enabled: true,\n  },` : ''}${oauthProviders.length > 0 ? `\n  socialProviders: {\n${socialProviders}\n  },` : ''}\n});`;\n  }\n\n  // Default to Drizzle\n  return `import { betterAuth } from \"better-auth\";\nimport { drizzleAdapter } from \"better-auth/adapters/drizzle\";\nimport { db } from \"@/db\"; // Import your Drizzle database instance\n\nexport const auth = betterAuth({\n  database: drizzleAdapter(db, {\n    provider: \"pg\", // Options: \"pg\", \"mysql\", \"sqlite\"\n  }),${hasEmailPassword ? `\n  emailAndPassword: {\n    enabled: true,\n  },` : ''}${oauthProviders.length > 0 ? `\n  socialProviders: {\n${socialProviders}\n  },` : ''}\n});`;\n}\n\n/**\n * Generate auth client helper\n */\nexport function generateAuthClient(framework: Framework = \"next\"): string {\n  let envVar = 'process.env.NEXT_PUBLIC_APP_URL';\n  \n  if (framework === \"react\" || framework === \"tanstack\") {\n    envVar = 'import.meta.env.VITE_APP_URL';\n  } else if (framework === \"remix\") {\n    // Remix client often uses window.ENV or just root loader data, but here we assume a standard setup or public env\n    // Better Auth client in Remix might often point to a full URL if separate, or relative.\n    // Let's assume standard VITE_ convention if they use Vite-Remix, or process.env if they use Classic Remix?\n    // Modern Remix uses Vite. So usually import.meta.env.VITE_ or just /api/auth\n    envVar = 'import.meta.env.VITE_APP_URL'; \n  }\n\n  return `import { createAuthClient } from \"better-auth/react\";\n\nexport const { signIn, signOut, signUp, useSession } = createAuthClient({\n  baseURL: ${envVar} || \"http://localhost:3000\",\n});`;\n}\n\n/**\n * Generate Prisma schema for Better Auth\n */\nexport function generatePrismaSchema(): string {\n  return `// prisma/schema.prisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\" // or \"mysql\", \"sqlite\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id            String    @id @default(cuid())\n  email         String    @unique\n  emailVerified Boolean   @default(false)\n  name          String?\n  image         String?\n  createdAt     DateTime  @default(now())\n  updatedAt     DateTime  @updatedAt\n  \n  accounts      Account[]\n  sessions      Session[]\n}\n\nmodel Account {\n  id                String  @id @default(cuid())\n  userId            String\n  type              String\n  provider          String\n  providerAccountId String\n  refresh_token     String?\n  access_token      String?\n  expires_at        Int?\n  token_type        String?\n  scope             String?\n  id_token          String?\n  session_state     String?\n  \n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n  \n  @@unique([provider, providerAccountId])\n}\n\nmodel Session {\n  id           String   @id @default(cuid())\n  sessionToken String   @unique\n  userId       String\n  expires      DateTime\n  \n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n}\n\nmodel VerificationToken {\n  identifier String\n  token      String   @unique\n  expires    DateTime\n  \n  @@unique([identifier, token])\n}`;\n}\n\n/**\n * Generate Drizzle schema for Better Auth\n */\nexport function generateDrizzleSchema(): string {\n  return `// db/schema.ts\nimport { pgTable, text, timestamp, boolean, integer } from \"drizzle-orm/pg-core\";\n\nexport const user = pgTable(\"user\", {\n  id: text(\"id\").primaryKey(),\n  email: text(\"email\").notNull().unique(),\n  emailVerified: boolean(\"emailVerified\").notNull().default(false),\n  name: text(\"name\"),\n  image: text(\"image\"),\n  createdAt: timestamp(\"createdAt\").notNull().defaultNow(),\n  updatedAt: timestamp(\"updatedAt\").notNull().defaultNow(),\n});\n\nexport const account = pgTable(\"account\", {\n  id: text(\"id\").primaryKey(),\n  userId: text(\"userId\")\n    .notNull()\n    .references(() => user.id, { onDelete: \"cascade\" }),\n  type: text(\"type\").notNull(),\n  provider: text(\"provider\").notNull(),\n  providerAccountId: text(\"providerAccountId\").notNull(),\n  refresh_token: text(\"refresh_token\"),\n  access_token: text(\"access_token\"),\n  expires_at: integer(\"expires_at\"),\n  token_type: text(\"token_type\"),\n  scope: text(\"scope\"),\n  id_token: text(\"id_token\"),\n  session_state: text(\"session_state\"),\n});\n\nexport const session = pgTable(\"session\", {\n  id: text(\"id\").primaryKey(),\n  sessionToken: text(\"sessionToken\").notNull().unique(),\n  userId: text(\"userId\")\n    .notNull()\n    .references(() => user.id, { onDelete: \"cascade\" }),\n  expires: timestamp(\"expires\").notNull(),\n});\n\nexport const verificationToken = pgTable(\"verificationToken\", {\n  identifier: text(\"identifier\").notNull(),\n  token: text(\"token\").notNull().unique(),\n  expires: timestamp(\"expires\").notNull(),\n});`;\n}\n\n/**\n * Generate Prisma client setup\n */\nexport function generatePrismaClient(): string {\n  return `// lib/prisma.ts\nimport { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient();\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;`;\n}\n\n/**\n * Generate Drizzle client setup\n */\nexport function generateDrizzleClient(framework: Framework = \"next\"): string {\n  let envVar = 'process.env.DATABASE_URL!';\n  \n  if (framework === \"react\" || framework === \"tanstack\" || framework === \"remix\") {\n    // Client-side DB access isn't safe, but Drizzle client file is usually server-side.\n    // React/Vite/TanStack Start (server functions) use Vite envs or standard process.env depending on runtime.\n    // For TanStack Start (server), it's process.env or import.meta.env\n    // Let's stick to process.env for Server-Side code (DB connection) which is safer assumption for backend.\n    // Except Vite which might use import.meta.env\n    if (framework === \"react\") {\n       // React SPA shouldn't have DB connection code client-side. Warning? \n       // But we generate it anyway for the 'backend' part.\n       envVar = 'process.env.DATABASE_URL!';\n    } else {\n       // TanStack Start / Remix (Server)\n       envVar = 'process.env.DATABASE_URL!';\n    }\n  }\n\n  return `// db/index.ts\nimport { drizzle } from \"drizzle-orm/postgres-js\";\nimport postgres from \"postgres\";\nimport * as schema from \"./schema\";\n\nconst connectionString = ${envVar};\nconst client = postgres(connectionString);\n\nexport const db = drizzle(client, { schema });`;\n}\n",
      "type": "registry:lib",
      "target": "lib/form-generator.ts"
    },
    {
      "path": "src/registry/default/types.ts",
      "content": "import * as z from \"zod\";\nimport { type OAuthProvider } from \"@/lib/oauth-providers-config\";\n\nexport interface FormField {\n  type: \"input\" | \"textarea\" | \"select\" | \"checkbox\" | \"radio\";\n  name: string;\n  label: string;\n  placeholder?: string;\n  description?: string;\n  required?: boolean;\n  options?: Array<{ label: string; value: string }>;\n  inputType?: \"text\" | \"email\" | \"password\" | \"tel\" | \"url\" | \"number\" | \"date\";\n}\n\nexport interface FormTemplate {\n  id: string;\n  name: string;\n  description: string;\n  category: \"authentication\" | \"contact\" | \"ecommerce\" | \"survey\" | \"profile\" | \"booking\";\n  schema: z.ZodObject<any>;\n  defaultValues: Record<string, any>;\n  fields: FormField[];\n  oauthProviders?: OAuthProvider[];\n}\n",
      "type": "registry:lib",
      "target": "lib/types.ts"
    }
  ],
  "type": "registry:lib"
}